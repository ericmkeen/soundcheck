#' Launch the `soundcheck` app
#'
#' This app allows you to analyze a folder of `.wav` files: review spectrograms,
#' playback the sound, and label the contents of each file using your own custom categories.
#'
#' @param settings A `soundcheck` settings list, generated by `soundcheck_settings()`
#' (see the documentation for that function).
#'
#' @param wav_folder The path (relative or absolute) to your folder of `.wav` files.
#' The default is a subfolder named `wav` within your working directory.
#'
#' @param wav_start The index of the `wav` file to begin with when opening the app.
#'
#' @param labels_file  The filepath (relative or absolute) to a `.csv` of label results.
#' The default is `labels.csv` within your working directory.
#' If this file does not yet exist, the function will automatically create this file
#' based upon your settings.
#'
#' @param events_file  The filepath (relative or absolute) to a `.csv` of events details
#' (i.e., discrete occurrences within sound files that are marked manually by the analyst).
#' The default is `evetns.csv` within your working directory.
#' If this file does not yet exist, the function will automatically create this file
#' based upon your settings.
#'
#'#' @return A `Shiny` app will open, displaying the spectrogram of the first recording
#' in your `wav_folder`. You can then navigate to other sound files as needed.
#'
#' @details The basic workflow is:
#' \enumerate{
#' \item (Make sure you have prepared your `settings` argument using the `soundcheck_settings()` function.
#' \item Run this function command to launch the Shiny app, which will open a browser window.
#' In the top center of the window, you will see a spectrogram of your first sound file
#' (it may take a few seconds to render).
#' \item Specify the analyst name in the top-left of the app.
#' \item Adjust spectrogram display as you need, using the slider settings.
#' Definitions for these settings are provided in the documentaiton for the `Spectrogram()` function.
#' Note that updating the spectrogram may take several seconds,
#' depending on the sample rate and duration of your recording.
#' If your sound files all have the same parameters (same sample rate,
#' similar frequency range of interest, and similar duration),
#' it may be beneficial to use the slider settings to optimize the spectrogram display,
#' *then* revise the spectrogram parameters you specified in your `soundcheck_settings()` call, *then* re-launch the app.
#' Doing so would save you the trouble of re-optimizing those slider settings
#' every time you (or a colleague) close and re-open the app while working on the same project.
#' Finally, note that the width of the displayed spectrogram may depend on the duration of your sound file;
#' files less than 30 seconds in duration will be scaled according to their duration,
#' so that short files are not too distorted by the aspect ratio of the display.
#' \item Listen to the recording (or a certain part of it), if you wish,
#' by double-clicking anywhere on the spectrogram. (To listen to the whole thing,
#' click on the far left of the spectrogram.)
#' Double-click again to stop playback. Adjust playback speed if you want, using the slider settings.
#' \item Below the spectrogram, you will see the label categories you specified in your `soundcheck_settings()` call.
#' Use those menus to label the features (or lack of features) in this sound file
#' \item To save your labels to your `labels_file`, click "Save & Next".
#' (To navigate to other files without saving your labels,
#' you can use the "Skip" or "Back" buttons, or manually select the file of your choice.).
#' Your labels will *only* be saved when you click "Save & Next" --
#' labels will *not* be saved when you click "Skip" or "Back".
#' \item If you are reviewing a file that already has a label record in the `labels_file`,
#' those previous labels will be printed
#' in a table for the analyst to review. You can inspect the entire contents
#' of your `labels_file` using the table printed at the bottom of the app
#' (you may need to scroll down to find this table).
#' \item To filter the `.wav` files within your `wav_folder` --
#' e.g., to only the recordings you have not yet labeled, or only the recordings that you *have* already labeled --
#' you can use the "Filter" dropdown menu (top-left in app).
#' \item You can also **annotate** files by noting discrete events within them. You do this
#' by single-clicking on a point of the spectrogram. The timestamp (in milleseconds)
#' and frequency of your cursor will be stored within the `events.csv` output file.
#' \item When your work session is over, simply close the browser window.
#' If you modified the spectrogram settings during your work session,
#' take note of those changes in a notebook (they will be reset when you re-launch the app) --
#' or, better yet, modify the corresponding settings in your `soundcheck_settings()` call,
#' so that the app will re-launch for your next session using the settings you have been optimizing while you work.
#' }
#'
#' When you are working on a large batch of sound files, the typical procedure will be:
#' (1) launch the app; (2) set your analyst name; (3) change the "Filter" menu to
#' 'Not yet labeled'; (4) resume labeling.
#'
#' Note that this app is optimized for `.wav` files with sampling rates of 44.1 kHz or lower, 1 minute or less,
#' but you may be able to adjust the spectrogram settings to make your files work.
#'
#' @import shiny
#' @import magrittr
#' @import dplyr
#' @import shinythemes
#' @export
#'
soundcheck_app <- function(settings,
                           wav_folder = 'wav',
                           wav_start = 1,
                           labels_file = 'labels.csv',
                           events_file = 'events.csv'){

  if(FALSE){ # code for debugging -- not run!
    wav_folder = 'wav'
    wav_start <- 1
    labels_file = 'labels.csv'
    verbose = TRUE

    # Test it
    settings <-
      soundcheck_settings(
        labels = list(Target_species = c('Not present','Present', 'Not sure'),
                      Anthropogenic_noise = c('Not present','Present', 'Not sure'),
                      Third_thing = c('Who knows','Who cares', 'Why me'),
                      Fourth_thing = c('Live to Breathe','Breathe to Live', 'Whatever')))
    settings

    soundcheck_app(settings = settings,
                   wav_folder = 'wav',
                   labels_file = 'labels.csv')

  }

  ##############################################################################
  # Process settings

  settings

  # Prepare list of WAV files
  (wavs <- dir(wav_folder, all.files=FALSE))
  (wavs <- wavs[grep('wav',wavs)])
  (wavs <- paste0(wav_folder,'/',wavs))
  if(length(wavs)==0){
    stop('No WAV files found! Stopping here.\n  Double check your working directory / `wav_folder` argument, then try again.')
  }

  # Make sure the labels file is a CSV
  if(length(grep('csv',labels_file))==0){
    stop('Wait! The labels file you specified is not a CSV.\n  Stopping here!\n  Provide a full filename for a CSV file.')
  }

  # Save the list of analysts as its own object
  analysts <- settings$analysts
  if(settings$na_default){(analysts <- c("N/A",analysts))}

  # Save the list of label categories/options as its own object
  (cats <- settings$labels)
  if(settings$na_default){
    (cats <- lapply(cats,function(x){c("N/A",x)}))
    #cats$options <- lapply(cats$options,function(x){c("N/A",x)})
  }

  # Create vector of columns expected in the labels file
  (result_columns <- tolower(c('wav',
                               gsub(' ',',',names(cats)),
                               'analyst','datetime','comment')))

  # If the labels file already exists, make sure it has the right number of columns
  if(file.exists(labels_file)){
    if(file.size(labels_file) > 1){
      df <- read.csv(labels_file)
      if(nrow(df)>0){
        if(length(names(df)) != length(result_columns)){
          stop('Wait! Labels file is non-empty but has a different number of labels columns.\n  Stopping here!\n  Reconcile your settings with your existing labels file, or provide a name to a different/new label .csv')
        }
      }
    }
  }

  if(!file.exists(labels_file)){
    file.create(labels_file)

    # Add column names
    cat(paste(result_columns,collapse=','),
        file=labels_file,
        sep='\n',
        append=TRUE)
  }

  # Create the events file
  (event_columns <- tolower(c('wav', 'ms', 'hz',
                               'analyst','datetime')))
  if(!file.exists(events_file)){
    file.create(events_file)

    # Add column names
    cat(paste(event_columns,collapse=','),
        file=events_file,
        sep='\n',
        append=TRUE)
  }

  if(TRUE){
    ##############################################################################
    ##############################################################################
    ##############################################################################
    # UI

    ui <- shiny::shinyUI(
      shiny::tagList( #needed for shinyjs
        shinyjs::useShinyjs(),  # Include shinyjs
        rintrojs::introjsUI(),   # Required to enable introjs scripts
        shiny::navbarPage(id = "intabset", #needed for landing page
                          title = 'Soundcheck',
                          windowTitle = "Soundcheck", #title for browser tab
                          theme = shinythemes::shinytheme("cerulean"), #Theme of the app (blue navbar)
                          collapsible = TRUE #tab panels collapse into menu in small screens
        ),
        shiny::mainPanel(width = 10, style="margin-left:4%; margin-right:4%",
                         ##############################################################################
                         ##############################################################################

                         shiny::fluidRow(shiny::column(3,shiny::selectInput('analyst','Select analyst',
                                                                            choices=analysts, selected = analysts[1])),
                                         shiny::column(3,shiny::selectInput('filter','Filter file list?',
                                                                            choices=c('All','Not yet labeled','Already labeled'), selected='All',width='95%')),
                                         shiny::column(2,shiny::textOutput('files_counted')),
                                         shiny::column(2,shiny::textOutput('files_labeled')),
                                         shiny::column(2,shiny::textOutput('files_staged'))),
                         shiny::br(),
                         shiny::fluidRow(shiny::column(1),shiny::column(11,shiny::textOutput('current_filename'))),
                         shiny::uiOutput('spectrogram_row'),
                         shiny::fluidRow(shiny::column(1), shiny::column(11,shiny::helpText('Double-click anywhere on spectrogram to play sound from that point; double-click again to stop.'))),
                         shiny::br(),
                         shiny::fluidRow(shiny::uiOutput('labels_row')),
                         shiny::fluidRow(shiny::column(12,shiny::textInput('comment','Comment? (optional):',width='100%'))),
                         shiny::fluidRow(shiny::column(5,shiny::actionButton('save_next',shiny::h4('Save & Next'),width='100%')),
                                         shiny::column(2,shiny::actionButton('skip',shiny::h5('Skip'),width='100%')),
                                         shiny::column(2,shiny::actionButton('back',shiny::h5('Back'),width='100%')),
                                         shiny::column(3,shiny::uiOutput('manual_select'))),
                         shiny::fluidRow(shiny::column(12,
                                                       shiny::uiOutput('dfi_show'),
                                                       DT::dataTableOutput('dfi'))),
                         shiny::hr(),
                         shiny::fluidRow(shiny::column(4,shiny::sliderInput('speed',shiny::h5('Playback speed'), min=0.1,max=5,value=1,step=.1,width='95%')),
                                         shiny::column(4,shiny::uiOutput('dynamic_range')),
                                         shiny::column(4,shiny::uiOutput('overlap'))),
                         shiny::br(),
                         shiny::fluidRow(shiny::column(6,shiny::uiOutput('frequency')),
                                         shiny::column(3,shiny::uiOutput('window_length')),
                                         shiny::column(3,shiny::uiOutput('freq_resolution'))),
                         shiny::hr(),
                         shiny::fluidRow(shiny::column(12,
                                                       shiny::h4('Labels thus far:'),
                                                       DT::dataTableOutput('df'))),
                         shiny::br()

                         ##############################################################################
                         ##############################################################################
        ),
        shiny::div(style = "margin-bottom: 30px;"), # this adds breathing space between content and footer
        shiny::tags$footer(shiny::column(6, "Â© Eric Keen & Ben Hendricks (2022)"),
                           style = "
   position:fixed;
   text-align:center;
   left: 0;
   bottom:0;
   width:100%;
   z-index:1000;
   height:30px; /* Height of the footer */
   color: white;
   padding: 10px;
   background-color: #1995dc"
        )
      ) # end of tag list
    )

    ##############################################################################
    ##############################################################################
    ##############################################################################
    # Server

    server <- function(input, output, session) {

      # Reactive values ==========================================================

      rv <- shiny::reactiveValues()
      rv$wav_files <- wavs # list of viable wav files
      rv$wav_file <- NULL # wav_file selected
      rv$wav_data <- NULL
      rv$wav <- NULL # wav object
      rv$i <- wav_start # index of selected wav file
      rv$play <- NULL
      rv$df <- read.csv(labels_file,stringsAsFactors=FALSE) # labels_file
      rv$dfi <- data.frame() # df filtered to labels for current wav file

      # File navigation ========================================================

      # WAV file options (responsive to Filter settings)
      observe({
        df <- rv$df
        filter_op <- input$filter
        #print(filter_op)
        wavs_raw <- wavs
        #print(wavs_raw)

        if(filter_op == 'Already labeled'){
          if(nrow(df)>0){
            keeps <- which(wavs_raw %in% df$wav)
            if(length(keeps)>0){
              wavs_raw <- wavs_raw[keeps]
            }else{
              wavs_raw <- c()
            }
          }
        }

        if(filter_op == 'Not yet labeled'){
          if(nrow(df)>0){
            keeps <- which(! wavs_raw %in% df$wav)
            if(length(keeps)>0){
              wavs_raw <- wavs_raw[keeps]
            }else{
              wavs_raw <- c()
            }
          }
        }

        if(length(wavs_raw) > 0){
          rv$wav_files <- wavs_raw
        }else{
          shiny::showModal(shiny::modalDialog(title="No more sounds to label!",
                                              "(According to your filter settings). Showing you all the files in your WAV folder...",
                                              size="m",easyClose=TRUE))
          rv$wav_files <- wavs
          shiny::isolate({shiny::updateSelectInput(session,'filter',selected='All')})
        }

        # Update index if needed
        if(rv$i > length(rv$wav_files)){rv$i <- length(rv$wav_files)}
        rv$wav_file <- rv$wav_files[rv$i]
      })

      # Manually select file
      output$manual_select <- shiny::renderUI({
        shiny::selectInput('manual_select',
                           'Manually select a file:',
                           choices = rv$wav_files,
                           selected = rv$wav_files[which(rv$wav_files %in% rv$wav_file)],
                           width='100%')
      })
      shiny::observeEvent(input$manual_select,{
        rv$i <- which(rv$wav_files %in% input$manual_select)
      })

      # Index of wav file selected -- when updated, update wav_file
      shiny:: observeEvent(rv$i,{
        shiny::isolate({
          i <- rv$i
          wav_files <- rv$wav_files
          rv$wav_file <- wav_files[i]
          #print(rv$wav_file)

          # Update rv$dfi (labels for current file)
          rv$dfi <- rv$df %>% dplyr::filter(wav == rv$wav_file)

          # Update selectInputs each time you navigate
          lapply(1:length(cats),
                 function(x){
                   shiny::isolate({shiny::updateSelectInput(session,
                                                            paste0('cat_',names(cats)[x]),
                                                            selected=cats[[x]][1])})
                 }
          )
          shiny:: isolate({shiny::updateTextInput(session, 'comment',value='')})

          # Turn off playback, if a sound is playing
          if(!is.null(rv$play)){rv$play <- audio::pause(rv$play) ; rv$play <- NULL}
        })
      })

      # Button: Save & Next
      shiny::observeEvent(input$save_next,{
        shiny::isolate({
          if(input$analyst == 'N/A'){
            shiny::showModal(shiny::modalDialog(title="Select an analyst name first!",
                                                "Silly goose!",
                                                size="m",easyClose=TRUE))
          }else{
            # Gather labels for the output line
            inputs <- shiny::reactiveValuesToList(input) # get list of all inouts
            catinputs <- grep('cat_',names(inputs)) # indices for inputs pertaining to labels
            df_labels <- c() # concatenate these labels into a character vector
            for(i in catinputs){
              df_labels <- c(df_labels, inputs[[i]])
            }

            if(any(df_labels == 'N/A')){
              shiny::showModal(shiny::modalDialog(title="You have to make a decision for each label!",
                                                  "Are you a pelican, or a pelican't???",
                                                  size="m",easyClose=TRUE))
            }else{
              df_labels <- paste(df_labels,collapse=',') # collapse this vector, sep by comma
              #print(df_labels)

              # Prepare output to save
              df_line <- paste(c(rv$wav_file,
                                 df_labels,
                                 input$analyst,
                                 as.character(Sys.time()),
                                 gsub(',',';',input$comment)),
                               collapse=',')
              #print(df_line)

              # Write output to labels_file
              cat(df_line, file=labels_file, sep='\n', append=TRUE)

              # Re-read the labels_file
              rv$df <- read.csv(labels_file,stringsAsFactors=FALSE)

              # Navigate
              if(input$filter == 'All'){
                rv$i <- ifelse(rv$i == length(rv$wav_files), 1, rv$i+1)
              }
            }
          }
        })
      })

      # Button: Skip
      shiny::observeEvent(input$skip,{
        isolate({
          if(rv$i == length(rv$wav_files)){
            shiny::showModal(shiny::modalDialog(title="You have reached the end of the file set!",
                                                "Bringing you back to the first file...",
                                                size="m",easyClose=TRUE))
          }
          rv$i <- ifelse(rv$i == length(rv$wav_files), 1, rv$i+1)
        })
      })

      # Button: Back
      shiny::observeEvent(input$back,{
        shiny::isolate({
          rv$i <- ifelse(rv$i == 1, length(rv$wav_files), rv$i-1)
        })
      })

      # Single click (an event)
      shiny::observeEvent(input$single_click,{
        shiny::isolate({
          if(input$analyst == 'N/A'){
            shiny::showModal(shiny::modalDialog(title="Select an analyst name first!",
                                                "Silly goose!",
                                                size="m",easyClose=TRUE))
          }else{
            sr <- rv$wav_data$sr
            x <- input$single_click$x
            y <- input$single_click$y
            # Determine position in milleseconds based on single click
            (msi <- (x/1000)*sr) # start position in milliseconds

            # Prepare output to save
            df_line <- paste(c(rv$wav_file,
                               msi,
                               y,
                               input$analyst,
                               as.character(Sys.time())),
                             collapse=',')
            print(df_line)

            # Write output to events_file
            cat(df_line, file=events_file, sep='\n', append=TRUE)
          }
        })
      })


      # Spectrogram ============================================================

      # Prep wav_data
      observeEvent(rv$wav_file,{
        isolate({
          wav_data <- NULL
          wav_file <- rv$wav_file
          #wav_file <- 'wav/demo-04.wav'
          #wav_file <- 'wav/demo-05.wav'

          (ok_test <- !is.null(wav_file))
          if(ok_test){(ok_test <- file.exists(wav_file))}
          if(ok_test){
            lw <- tuneR::readWave(wav_file)
            (sr <- lw@samp.rate)
            (wav_duration <- length(lw@left) / (2*sr))
            (bits <- lw@bit)
            lw <- audio::as.audioSample(x = lw@left, rate = sr, bits = bits)
            wav_data <- list(lw=lw,
                             sr=sr,
                             wav_duration=wav_duration,
                             bits=bits)
          }
          rv$wav_data <- wav_data

          #if(FALSE){
          #  sr
          #  play_test <- audio::play(lw, rate = sr)
          #  play_test <- audio::pause(play_test)
          #}

        })
      })

      output$spectrogram_row <- shiny::renderUI({

        if(!is.null(rv$wav_data)){
          wav_duration <- rv$wav_data$wav_duration

          if(wav_duration > 30){
            shiny::fluidRow(shiny::column(12,
                                          shiny::plotOutput("spectrogram",
                                                            height="200px",
                                                            click = 'single_click',
                                                            dblclick = "dbl")))
          }else{
            secs <- 1:30
            cols <- seq(3,10,length=length(secs))
            fft_col <- ceiling(cols[which.min(abs(wav_duration - secs))]) ; fft_col
            side_col <- floor((12 - fft_col) / 2) ; side_col
            fft_col <- 12 - 2*side_col ; fft_col
            if(side_col < 1){side_col <- 1}
            if(fft_col > 10){fft_col <- 10}

            shiny::fluidRow(shiny::column(side_col),
                            shiny::column(fft_col,
                                          shiny::plotOutput("spectrogram", height="200px",
                                                            dblclick = "dbl")),
                            shiny::column(side_col))
          }
        }
      })

      output$dynamic_range <- renderUI({
        shiny::sliderInput("dynamic_range",label=shiny::h5("Spectrogram sensitivity"),
                           min=0,max=100,
                           value=settings$dynamic_range,step=5,width="95%")
      })
      output$overlap <- renderUI({
        shiny::sliderInput("overlap",shiny::h5("Temporal resolution"),
                           min=0,max=1,step=.05,
                           value=settings$overlap)
      })
      output$frequency <- renderUI({
        shiny::sliderInput('frequency',shiny::h5('Frequency range'),
                           min=0,
                           max=8000,
                           step=50,
                           value=c(settings$frequency_min,settings$frequency_max),
                           #value=c(200,900),
                           width='95%')
      })
      output$window_length <- renderUI({
        shiny::sliderInput('window_length',shiny::h5('FFT window length:')
                           ,min=10,max=1000,
                           value=settings$window_length,step=2)
      })
      output$freq_resolution <- renderUI({
        shiny::sliderInput('freq_resolution',shiny::h5('Frequency resolution'),
                           min=1, max=10,
                           value=settings$frequency_resolution,
                           step=1)
      })

      output$spectrogram <- shiny::renderPlot({
        #print('bench 1')
        wav_file <- rv$wav_file
        #wav_file <- 'wav/demo-5.wav'
        (ok_test <- !is.null(wav_file))
        if(ok_test){(ok_test <- file.exists(wav_file))}
        if(ok_test){
          #print('bench 2')

          # Read in wav file
          wav <- tuneR::readWave(filename=wav_file)

          # Handle settings
          if(FALSE){
            ylim <- c(200, 2000)
            dynamic_range <- 40
            overlap <- .3
            window_length <- 350
            frequency_resolution <- 4
            window_type <- 'hamming'
          }

          ylim <- input$frequency # ; ylim <- c(200,900)
          dynamic_range <- input$dynamic_range
          overlap <- input$overlap # time resolution
          window_length <- input$window_length #; 350
          frequency_resolution <- input$freq_resolution #;4
          window_type <-settings$window_type

          timestep_size <- overlap*window_length

          #print('bench 3')

          # Display spectrogram
          par(mfrow=c(1,1), mar=c(4.2,4.2,.1,.5))
          Spectrogram( Audio=wav,
                       SamplingFrequency=NULL,
                       WindowLength = window_length,
                       FrequencyResolution = frequency_resolution,
                       TimeStepSize = timestep_size,
                       nTimeSteps = NULL,
                       Preemphasis = TRUE,
                       DynamicRange = dynamic_range,
                       Omit0Frequency = FALSE,
                       WindowType = window_type,
                       WindowParameter = NULL,
                       plot = TRUE,
                       PlotFast = TRUE,
                       add = FALSE,
                       col = NULL,
                       xlim = NULL,
                       ylim = ylim,
                       xlab = "Time (ms)",
                       ylab = "Frequency (Hz)")
        }
      })


      # Playback =================================================================

      shiny::observeEvent(input$dbl,{
        shiny::isolate({
          if(is.null(rv$play)){
            if(!is.null(rv$wav_data)){

              x <- input$dbl$x # double click position
              #x <- 1000

              lw <- rv$wav_data$lw
              sr <- rv$wav_data$sr

              # Determine start position based on double click
              (ms_start <- (x/1000)*sr) # start position in milliseconds
              # Subset wav object according to start position
              #lw_sub <- lw[ms_start:min(c(length(lw), ms_start + (10*sr)))]
              lw_sub <- lw[ms_start:length(lw)]

              # Adjust sample rate based on playback speed
              playback_speed <- input$speed
              sr_playback <- sr*playback_speed

              # Playback
              rv$play <- audio::play(lw_sub, rate = sr_playback)

              #pause(playback)
              #print(input$dbl)
            }
          }else{
            rv$play <- audio::pause(rv$play)
            rv$play <- NULL
          }
        })
      })

      # Dynamic UI outputs =======================================================

      # Status texts above spectrogram
      output$files_counted <- shiny::renderText({shiny::HTML(paste0(length(wavs),' file(s) in /',wav_folder))})

      output$files_staged <- shiny::renderText({shiny::HTML(paste0(length(rv$wav_files),' file(s) staged for labeling.'))})

      output$files_labeled <- shiny::renderText({
        if(nrow(rv$df)>0){
          HTML(paste0(length(unique(rv$df$wav)),' file(s) already labeled.'))
        }else{
          HTML(paste0('No labels yet!'))
        }
      })

      # Display the current filename
      output$current_filename <- shiny::renderText({ rv$wav_file })

      # Dynamic UI that creates the label categories
      output$labels_row <- shiny::renderUI({
        colwidth <- floor(12 / length(cats))
        lapply(1:length(cats),
               function(x){
                 shiny::column(colwidth,shiny::selectInput(paste0('cat_',names(cats)[x]),
                                                           label=names(cats)[x],
                                                           choices=cats[[x]],
                                                           selectize=FALSE,
                                                           size=length(cats[[1]])))
               })
      })

      output$dfi_show <- shiny::renderUI({
        if(nrow(rv$dfi)>0){
          shiny::h5('Previous labels for this sound file:')
        }
      })
      output$dfi <- DT::renderDataTable(if(nrow(rv$dfi)>0){rv$dfi})

      # Datatable for labels currently in labels_file
      output$df <- DT::renderDataTable(rv$df %>% dplyr::arrange(desc(datetime)))

    }

    ########################################get######################################
    ##############################################################################
    ##############################################################################
    # Run app
    shiny::shinyApp(ui = ui, server = server)
  }
}
